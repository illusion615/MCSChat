<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quick Speech Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .status {
            margin: 15px 0;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #cce7ff; color: #004085; }
        select, input {
            margin: 5px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¤ Quick Speech Test</h1>
        <p>Simple test to verify speech engine functionality</p>
        
        <div style="background: #e3f2fd; padding: 15px; border-radius: 6px; margin: 15px 0; border-left: 4px solid #2196f3;">
            <strong>ðŸ’¡ Recommendation:</strong> Use <strong>Enhanced Web Speech API</strong> for best results!<br>
            âœ… Immediate availability â€¢ âœ… High quality voices â€¢ âœ… Perfect for streaming speech â€¢ âœ… No downloads required
        </div>
        
        <div id="status" class="status info">Initializing...</div>
        
        <div style="margin: 20px 0;">
            <label>Provider: </label>
            <select id="provider">
                <option value="web_speech">Enhanced Web Speech API (Recommended)</option>
                <option value="local_ai">Local AI Models (Experimental - May Take Time to Load)</option>
                <option value="azure">Azure Speech Services (Requires Configuration)</option>
            </select>
            
            <label style="margin-left: 15px;">Voice: </label>
            <select id="voice"></select>
        </div>
        
        <div style="margin: 20px 0;">
            <label>Rate: </label>
            <input type="range" id="rate" min="0.5" max="2" step="0.1" value="1">
            <span id="rateDisplay">1.0</span>
            
            <label style="margin-left: 15px;">Volume: </label>
            <input type="range" id="volume" min="0.1" max="1" step="0.1" value="1">
            <span id="volumeDisplay">1.0</span>
        </div>
        
        <div style="margin: 20px 0;">
            <button id="testBasic">Test Basic Speech</button>
            <button id="testStreaming">Test Streaming Simulation</button>
            <button id="stopSpeech">Stop Speech</button>
        </div>
        
        <div style="margin: 20px 0;">
            <textarea id="customText" placeholder="Enter custom text to speak..." 
                      style="width: 100%; height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 4px;"></textarea>
            <button id="speakCustom">Speak Custom Text</button>
        </div>
        
        <div id="log" style="height: 200px; overflow-y: auto; background: #f8f9fa; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px;"></div>
    </div>

    <script type="module">
        import { SpeechEngine } from './src/services/speechEngine.js';
        
        let speechEngine;
        
        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.innerHTML = `[${timestamp}] ${message}`;
            div.style.color = type === 'error' ? '#d32f2f' : type === 'success' ? '#388e3c' : '#666';
            logEl.appendChild(div);
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }
        
        async function initialize() {
            try {
                updateStatus('Initializing speech engine...', 'info');
                log('Starting speech engine initialization...');
                
                speechEngine = new SpeechEngine();
                await speechEngine.initialize();
                
                updateStatus('Speech engine ready!', 'success');
                log('Speech engine initialized successfully', 'success');
                
                // Populate voice dropdown
                populateVoices();
                
                // Setup event listeners
                setupEventListeners();
                
                log(`Current provider: ${speechEngine.settings.provider}`, 'info');
                log(`Available voices: ${speechEngine.state.availableVoices.length}`, 'info');
                
            } catch (error) {
                updateStatus(`Initialization failed: ${error.message}`, 'error');
                log(`Initialization error: ${error.message}`, 'error');
                console.error('Initialization error:', error);
            }
        }
        
        async function populateVoices() {
            const voiceSelect = document.getElementById('voice');
            voiceSelect.innerHTML = '<option value="">Loading voices...</option>';
            
            try {
                if (speechEngine && speechEngine.state.currentProvider) {
                    let voices = [];
                    
                    // Get voices from current provider
                    if (speechEngine.state.currentProvider.getVoices) {
                        voices = await speechEngine.state.currentProvider.getVoices();
                    } else if (speechEngine.state.availableVoices) {
                        voices = speechEngine.state.availableVoices;
                    }
                    
                    voiceSelect.innerHTML = '<option value="">Select a voice...</option>';
                    
                    voices.forEach(voice => {
                        const option = document.createElement('option');
                        option.value = voice.localUri || voice.voiceURI || voice.name;
                        
                        let displayText = voice.name;
                        if (voice.description) {
                            displayText += ` - ${voice.description}`;
                        }
                        if (voice.lang) {
                            displayText += ` (${voice.lang})`;
                        }
                        
                        option.textContent = displayText;
                        if (voice.isDefault) {
                            option.selected = true;
                        }
                        voiceSelect.appendChild(option);
                    });
                    
                    log(`Loaded ${voices.length} voices for ${speechEngine.settings.provider}`, 'info');
                }
            } catch (error) {
                voiceSelect.innerHTML = '<option value="">Error loading voices</option>';
                log(`Error loading voices: ${error.message}`, 'error');
            }
        }
        
        function setupEventListeners() {
            document.getElementById('provider').addEventListener('change', async (e) => {
                try {
                    log(`Switching to provider: ${e.target.value}`, 'info');
                    await speechEngine.setProvider(e.target.value);
                    populateVoices();
                    log(`Switched to provider: ${e.target.value}`, 'success');
                } catch (error) {
                    log(`Provider switch failed: ${error.message}`, 'error');
                }
            });
            
            document.getElementById('voice').addEventListener('change', async (e) => {
                try {
                    const selectedVoice = e.target.value;
                    if (selectedVoice) {
                        // Handle Local AI voice selection differently
                        if (speechEngine.settings.provider === 'local_ai' && speechEngine.state.currentProvider?.setVoice) {
                            await speechEngine.state.currentProvider.setVoice(selectedVoice);
                            log(`Local AI voice changed to: ${selectedVoice}`, 'info');
                        } else {
                            // Regular voice setting for other providers
                            speechEngine.setVoice(selectedVoice);
                            log(`Voice changed to: ${selectedVoice}`, 'info');
                        }
                    }
                } catch (error) {
                    log(`Failed to change voice: ${error.message}`, 'error');
                }
            });
            
            document.getElementById('rate').addEventListener('input', (e) => {
                speechEngine.setSpeechRate(parseFloat(e.target.value));
                document.getElementById('rateDisplay').textContent = e.target.value;
            });
            
            document.getElementById('volume').addEventListener('input', (e) => {
                speechEngine.setSpeechVolume(parseFloat(e.target.value));
                document.getElementById('volumeDisplay').textContent = e.target.value;
            });
            
            document.getElementById('testBasic').addEventListener('click', () => {
                testSpeech('Hello! This is a basic speech test. The speech engine is working correctly.');
            });
            
            document.getElementById('testStreaming').addEventListener('click', testStreamingSimulation);
            
            document.getElementById('stopSpeech').addEventListener('click', () => {
                speechEngine.stopSpeaking();
                log('Speech stopped', 'info');
            });
            
            document.getElementById('speakCustom').addEventListener('click', () => {
                const text = document.getElementById('customText').value.trim();
                if (text) {
                    testSpeech(text);
                } else {
                    log('Please enter some text to speak', 'error');
                }
            });
        }
        
        async function testSpeech(text) {
            try {
                log(`Speaking: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`, 'info');
                await speechEngine.speakText(text);
                log('Speech completed successfully', 'success');
            } catch (error) {
                log(`Speech error: ${error.message}`, 'error');
            }
        }
        
        async function testStreamingSimulation() {
            const testText = "This is a streaming speech simulation. The text will appear gradually, and speech should start immediately when complete sentences are detected. This demonstrates the real-time streaming speech functionality.";
            
            log('Starting streaming simulation...', 'info');
            
            // Clear any existing speech
            speechEngine.stopSpeaking();
            
            let currentIndex = 0;
            const interval = setInterval(async () => {
                currentIndex += Math.random() * 15 + 5; // Random chunk size
                
                if (currentIndex >= testText.length) {
                    clearInterval(interval);
                    currentIndex = testText.length;
                    log('Streaming simulation completed', 'success');
                }
                
                const currentText = testText.substring(0, currentIndex);
                log(`Streaming progress: ${Math.round((currentIndex / testText.length) * 100)}%`, 'info');
                
                // In a real implementation, this would be handled by messageRenderer
                // For this test, we'll just speak the complete text when streaming finishes
                if (currentIndex >= testText.length) {
                    await testSpeech(testText);
                }
            }, 200);
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
